#!/usr/bin/env zsh
autoload -Uz colors && colors

local VERSION="0.0.1"
local USAGE=(
  "Usage: s0cks [-h|--help] [<cmd>]"
  "General Options:"
  "  -h|--help        # Print help and usage info"
  "  -v|--verbose     # Print more, mostly debug, info to the console while working"
  "  --version        # Prints the version"
  ""
  "cmds:"
  "   version         # Prints the version"
  "   update [target] # Perform an update with an optional target"
)
local verbose=false
local update_target
local DOTFILES_DIR=${DOTFILES_DIR:-/usr/local/share/dotfiles}
local NEOVIM_DIR=${NEOVIM_HOME:-${XDG_CONFIG_HOME}/nvim}
local WEZTERM_DIR=${WEZTERM_HOME:-${XDG_CONFIG_HOME}/wezterm}
local HAMMERSPOON_DIR=${HAMMERSPOON_DIR:-${XDG_CONFIG_HOME}/hammerspoon}

local __show_help() {
  printf "%s\n" $USAGE
}

local __show_version() {
  printf "s0cks %s\n" "$VERSION"
}

local __done() {
  echo "$fg[green]${reset_color} done."
}

local __updated() {
  local name="$update_target"
  local revision="$(git log -1 --pretty='%h %B')"
  echo "$fg[green] $fg[bold]$fg[magenta]$name$reset_color updated to: $revision"
}

local __pull_changes() {
  local name="$update_target"
  local version="$(git rev-parse --abbrev-ref HEAD)"
  local remote="$(git remote get-url origin)"
  git pull --recurse-submodules &>/dev/null
  if (( "$?" != 0 )); then
    echo "$fg[red]$reset_color failed. Can't update $name $version from remote: $remote"
    return 1
  fi
  return 0
}

local __no_updates() {
  echo "$bold$fg[yellow]$reset_color skipped, no updates."
}

local __updating() {
  local name="$update_target"
  if [[ "$verbose" == "true" ]]; then
    echo "updating $bold$fg[magenta]$name$reset_color in $fg[cyan]$(pwd)$reset_color...."
  else
    echo "updating $bold$fg[magenta]$name$reset_color...."
  fi
}

local __update_dotfiles() {
  update_target="dotfiles"
  pushd "$DOTFILES_DIR/"
  local prev="$(git log -1 --pretty='%h')"
  __updating
  __pull_changes

  task install &>/dev/null
  if (( "$?" != 0)); then
    echo "$fg[red]${reset_color} failed to install dotfiles"
    return 1
  fi

  local crev="$(git log -1 --pretty='%h')"
  if [[ "$prev" != "$crev" ]]; then
    __updated
  else
    __no_updates
  fi
  popd &>/dev/null
  return 0
}

local __update_app_config() {
  update_target="$1"
  pushd "$2"
  local prev="$(git log -1 --pretty='%h')"
  __updating
  __pull_changes

  local crev="$(git log -1 --pretty='%h')"
  if [[ "$prev" != "$crev" ]]; then
    __updated
  else
    __no_updates
  fi
  popd &>/dev/null
  return 0
}

local __opterror() {
  echo >&2 "s0cks: invalid option '$1'"
}

local __invalid_command() {
  echo >&2 "s0cks: invalid command '$1'"
}

local __invalid_update_target() {
  echo >&2 "s0cks: invalid update target: '$1'" 
}

local cmd=()
while (( $# )); do
  case $1 in
    --)
      shift;
      cmd+=("${@[@]}");
      break
      ;;
    -h|--help)
      __show_help && return 0
      ;;
    -v|--verbose)
      verbose=true
      ;;
    --version)
      __show_version && return 0
      ;;
    -*)
      __opterr $1 && return 1
      ;; 
    *)
      cmd+=("${@[@]}");
      break
      ;;
  esac
  shift
done

if (( "${#cmd[@]}" == 0)); then
  __show_help && return 0
fi

local __update() {
  if (( "$#" == 0 )); then
    __update_dotfiles
  fi

  local target="$1"
  case "$target" in
  dotfiles)
    __update_dotfiles
    ;;
  nvim|neovim)
    __update_app_config "Neovim" "$NEOVIM_DIR"
    ;;
  wez|wezterm)
    __update_app_config "WezTerm" "$WEZTERM_DIR"
    ;;
  hs|hammerspoon)
    __update_app_config "Hammerspoon" "$HAMMERSPOON_DIR"
    ;;
  *)
    __invalid_update_target "$target" && return 1
    ;;
  esac
}

case "${cmd[1]}" in
  version)
    __show_version && return 0
    ;;
  update)
    shift cmd
    __update ${cmd[@]}
    ;; 
  *)
    __invalid_command ${cmd[1]} && return 1
    ;;
esac
